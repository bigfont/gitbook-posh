# Overview

This talk was conceived of a a conversation
with my friend and college Pat McGee. I wrote
it imagining that I was answering Pat's
questions about how to start with Git on
Windows. The result is an _opinionated_ guide
for getting started with Git on Windows.

# How do we install Git on Windows?

_____
So, Shaun. Let's get started. How do we install Git
on Windows?
_____

Chocolatey is the new-ish Windows package manager.
PowerShell is my prefered Git interface, and ConEmu
is my prefered way to use PowerShell.

The following is how to use Chocolatey
to install Git for use with PowerShell and ConEmu.

.Install chocolaty
[PowerShell]
----
> Invoke-Expression (curl 'https://chocolatey.org/install.ps1')
----

.Install MsysGit
[PowerShell,Chocolatey]
----
> choco install git
----

.Msysgit includes:
[NOTE]
====
. **Git SCM** (this is Git for Windows)
. **Git Bash** (emulation of Git in Linux)
. **Git GUI** (a basic GUI)
. **Shell Integration** (right click integration)
====

.Install PoshGit
[PowerShell,Chocolatey]
----
> choco install poshgit
----

.Install ConEmu
[PowerShell,Chocolatey]
-----
> choco install conemu
-----

Now we're ready to use Git with PowerShell and ConEmu.

# How do we create a local repo?

_____
Okay, so now we've installed Git the way that you like it.
How do create a repo?
_____

.Everything is local
[NOTE]
=====
Git is a distributed version control system.
A local repo has everything that a remote one has.
=====

Open PowerShell in ConEmu.
Then initiate a local git repository.

.Initiate a local Git repository
[PowerShell,Git]
----
# navigate to Documents
> cd ~\Documents

# Create and enter a GitDemo directory
> ni -t d GitDemo
> cd GitDemo

# Create and enter a repo1 directory
> ni -t d repo1
> cd repo1

# Turn it into a Git repo
> git init

# The repo1 directory now has a child .git directory
> dir -force -n
.git

----

# What's the most basic Git workflow?
_____
Great. We have a local repository. How do we use it?
_____

Since everything in Git is local, we can start
working with the repository locally, without the need
for a remote. This can be helpful for working on
personal projects that you might otherwise version
with ZIP files and timestampes.

Here's how to do basic, local version control with Git.

. Make changes to files in the working directory
. Stage those changes with `git add`
. Commit those changes with `git commit`
. Repeat
. Check Git status throughout with `git status`

.git add
[NOTE]
====
* In Git, we *add* a file to the *index*.
The index is also called the *staging area*.
The staging area is a list of all the files
that are going to be part of the next commit.

.Here it is in scematic form:
....
Working Directory > Staging Area > Repository
[make changes]    > [git add]    > [git commit]
....
====

.The most basic Git workflow
[PowerShell,Git]
-----
# create a file and check status
ni -t f file1.txt
git status

# stage the file and check status
git add file1.txt
git status

# commit the file
git commit -m "Add file1.txt"

# add some content to the file; save; check status
ac file1.txt "Some content"
git status

# stage the file; commit
git add file1.txt
git commit -m "Add content to file1.txt"
-----

When running `git status`, you'll see messages about
how your files are doing. From Git's perspective, your
files/working directory can be in one of four states:
untracked, staged, clean, modified.

.git status messages
[NOTE]
=====
Untracked files::
* Git knows these exist but isn't tracking them.
* So, you can stage, delete, or ignore them.
Changes to be committed (aka staged)::
* There are files in the index/staging area.
* So, you can commit them now.
Nothing to commit (aka clean)::
* You have no pending changes to any files.
* So, you can make changes or pull.
Modified::
* You have changed and saved a tracked file.
* So, you can stage the file.
=====

# How do we enlist in an existing repository?

[Hmm. Maybe remove this section and
instead jump right into working with GitHub,
because it's more practical. The local
remotes idea seems to be too esoteric.]

Okay, we have a local repository.
We have made several commits.
Now we want to share our work with others.

This will involve using *clone, fetch, and pull*
to work with a *remote*.

Git calls other repositories remotes;
although, these can be anywhere. Let's
setup another local repository using repo1
and the remote.

.Clone a remote
[PowerShell,Git]
-----
# clone repo1 into a repo2 directory
cd..
git clone C:\Users\BigFont\Documents\GitDemo\repo1 repo2

# repo2 now contains repo1's files
cd repo2
dir -n

# inspect the remotes
git remote -v
git remote show origin
-----

repo2 now has the same contents (within limits)
as does repo1. Also, repo2 has a master branch
that tracks the repo1/master branch. Within repo2,
we use *fetch* and *pull* to stay up to date
with repo1.

.Git fetch and git pull
[PowerShell,Git]
----
# create, stage and commit a new file to repo1
cd repo1
ni -t f file2.txt
git add file2.txt
git commit -m "Add file2.txt"
git log --oneline

# switch to repo2 and pull
cd ..\repo2
git pull
git log --oneline
----

After commiting changes to repo1, we are able
to pull them down into repo2.

# How do we contribute to an existign repo?

So far everything has been local. Let's keep
it that way for a little bit longer.

.bare repositories and git push
[NOTE]
====
We can only `git push` to a bare respository.
A bare repository contains only the contents
of the .git folder and has no working directory.
====
